# 1日目

## 21:10

とりあえず問題文を読む。
わからないけど、コンパイラ書けみたいな雰囲気を感じる。

とりあえず、なんらかの文字列を送る必要がありそうなので、post request 送るツールは作るか。

## 23:30

構文木をずっと書いてたんだけど、一生ラムダ抽象の構文をどう書いたらいいかわからなくて迷走してた。
書籍を読んだりしながらうんうん唸っていたら、普通に "L〇" の後に ICFP を一個読むようにすればつじつまが合うことに気付いた。
つまり、普通に一引数関数の `lambda x: x + 1` みたいに解釈すればよさそうという感じで、この例だと `L# B+ v# I"` となる。
ここまで解釈できれば後は気合い実装なので、明日やろう。形無しラムダ計算、本は読んだことあるけど多分インタプリタ実装するの初めてなので楽しみ～～

# 2日目

## 6:45

抽象構文木の実装始まり。

## 13:54

何度もリファクタリングをしたり、β-簡約周りの理解に結構詰まってしまったけど、ある程度まともなパースができるようになった！！🎉🎉
graphviz のビジュアライズ機能をつけたり色々頑張ったりして、面白いーー

- 何か長い文字列に対しては stack over flow が出る
- NodeFactory を実装しないと unique id が実現できない
    - unique id がないと、β-簡約する時に重複した node id を付与してしまって面倒なことになる

という部分は TODO として積んでおくことにする。
とりあえず、次は目に見えるパズルを解くシリーズをやってみる。

## 15:20

適用部分が一生バグってたけど、同名変数の扱いがおかしいことがわかり、とりあえず直したら hello が 1 になれた。
とりあえず一段落なんだけど、次何やればいいのか何もわかってないので、次に何をやるべきかを調べる。

## 15:59

何にもわからなかったので、試しに `get lambdaman` とか送ってみたら、何か問題が降ってきた。
わかりやすくてよかった～～

一通り scoreboard にある問題を取り寄せてみたけど、どうも 2, 3 問目などに手をつけないと次に進めないシステムらしい。
とりあえず、 lambdaman や spaceship をやることにしよう。

## 18:30

バグが取れないまま食事会へ。

## 23:30

帰宅。続きをやる。
よく考えたら、まだ変な動きをするパターンは考えられる。
多分なんだけど、一番最初に α-簡約をやらないとバグって死ぬケースがあると思う（自由変数を付け替えるタイミングがダメそう）。
明日そのバグを直す旅に出ようと思う。直らなかったら、困るな…

# 3日目

## 7:25

起きたので、開始。
デバッグの続き

## 8:05

β簡約を再帰で関数一度呼んだだけで解決しようと思ったのが間違いらしい。
何度もβ簡約するコードを呼ぶようにしたら解決した。

何かそれらしい lambdaman / spaceship の問題一覧が全部取れたっぽいので、ここから僕の ICFPC が始まる！！

lambdaman の問題を読んだ。ハミルトンパスを求めよという問題で、とりあえず LKH もどきを貼って終わりにしよう。
開始点を決めた時に、仮想頂点 V を決めて、V と現存頂点のコストを0にすることで、ハミルトン路を表現できるはず。

## 10:30

昔の TSP ソルバを持ってきて、繋げて全て解ききるところまでやった。
(ハミルトンパスのこと 1mm も考えてないので、自明な改善余地がある)
submit しようとしたんだけど色々面倒だから、コマンドや client を作るのがいいかなという気持ちになってきた。

ちょっとコマンドを整備しようかな。

## 11:17

とりあえず lambdaman で正の得点が取れるようになった。
何か lambdaman の best score が頭おかしいから絶対何か見落としがあるんだけど、よくわからんから一旦放置する。
(LKH の max-depth 2になってたので、流石にダメそう…)

次は spaceship の問題読む。

## 11:35

問題読んだ。
【要約】
無限に広い整数座標がある。
速度を↓↓の数字のパッドのように速度の増減を指定できるから、全ての頂点を訪れるのに必要な手数を求めよ。
1 2 3
4 5 6
7 8 9

うーん、適当に TSP で経路を求めて、そこまでのパスをビームサーチで求めるような感じになるのだろうか。
何か面倒そうだったので、他に簡単そうな問題がないかなーと思って全部の問題を確認することにした。

### 3d

謎の 2D 言語を使って、色んなアルゴの問題を解け！みたいなやつ。

### efficiency

追加の文法規則を使っていいから、parse にめちゃ時間かかる ICFP のパースをせよ！

どう考えても spaceship が一番楽そうで笑った。
次に面白そうなのが effieiency だなーと思うので、そこまで頑張って辿り着きたい気持ちがある。
とりあえず spaceship やるか～～

## 12:40

ところで、 lambdaman をずっと見てて、何でこれこんなにスコア高いの？みたいなのをずっと考えていたんだけど、
「スコアは POST の送信バイト数」というのを見て、ようやっとわかった。これ "S...." で送らずにプログラムとして記述して圧縮すると高得点になるんだ…
ひえーーーーなるほどーーーということに気付いた。
とりあえず、軽く一通りソルバ書いたら、どうやってこれを圧縮したらいいかを考えてみよう。
圧縮屋としてめっちゃ楽しそうすぎる。

時間が限られていることを考えると efficiency が明らかに楽しそうなので、とりあえずこっちやるか。

## 13:25

とりあえず、ラムダ式の表か戦略について勉強してみる。

* 最左最左簡約
    * https://scrapbox.io/mrsekut-p/%E6%9C%80%E5%B7%A6%E6%9C%80%E5%A4%96%E7%B0%A1%E7%B4%84
    * call by name, the normal order strategy
* 内部簡約：可簡約項の中で最も中にある可簡約項から簡約する方法．
    * https://research.nii.ac.jp/~hu/pub/teach/cm08/lambda.pdf

どんな感じの複雑な問題が出されるのかなーと思ってみてみたら、明らかに 4^22 であることが分かったので試しに提出してみたら通った。やったね！

## 14:30

とりあえず、call-by-need ができていないと話にならなさそうな雰囲気を感じるので、少し考えてみる。
何か抽象的すぎて何もわからんので、頻出するこの形について思いを馳せてみる。

- apply
    - lambda 1
        - apply
            - lambda 2
                - apply 
                    - variable 1
                    - apply
                        - variable 2
                        - variable 2
            - lambda 2
                - apply 
                    - variable 1
                    - apply
                        - variable 2
                        - variable 2
    - x

https://courses.engr.illinois.edu/cs421/sp2010/lectures/lecture27.pdf

この辺りも合わせて読んでみた。結局のところ「すぐに必要にならない評価はしない」ということに尽きるのだろうか。

何かデバッグしていてわかったけど、多分めちゃバグっていそうだとわかった。
（最初に木を操作して、unique な変数名を割り当てるべきだと思う）
ちょっと修正する。

修正したうえで、 graphviz に乗せてみたらわかったけど、評価する度にノードが4倍になる仕組みがめちゃめちゃわかって感動した。
alpha 変換がなされている前提であれば、 lazy とメモ化を組み合わせる所以もわかった気がする。
なので、efficiency-problem1 が解けなかった理由は本質的にメモ化だったんだなぁ。

この実装について少し考えてみる。
今、unique な node_id を定義したので、 HashMap<id, Node> のような構造を持ちたい。
Variable(X) に直接 Node を置換する代わりに、 Lazy(X) を入れておく。
Lazy(X) を評価するタイミングで、以下のことをやる

1. HashTable[X] に実体がなかったら、一度評価をして実体を作る
2. HashTable[X] に実体があったら、以降はそれを使いまわす

でも、何か Lazy 関係ない気もする。結局、Lazy の有無ってどこに evaluate を書くかだけだと思うしな。
とりあえずこれを書けば problem1 は通ると思う。

あとは、上記の無限ループパターンについて個別に考える必要がある。

よく考えたら、最初にそう言うサンプルをもらったので、あれを攻略できる自信がついたら実装する。

と思ったら、今まで無限ループしていた言語使用に書いてある言語が解けてしまっている…
え、もしかしてメモ化だけあれば解ける…？

## 16:53

ひたすらラムダ式をメモ化＋遅延評価で手動で簡約し続けた結果、確かにメモ化と遅延評価があれば解けそうという気持ちになった。
ここで重要なのは、以下だと感じた

- 基本的には、最外最左の評価でよさそうに思える
- Variable(X) を置換する処理において、Lazy(X) に置き換えて、HashMap[X] => Node(X) を登録する
    - 多分ここで一切 Node(X) を評価しないのが遅延評価の所以なのだと思う
- HashMap のキャッシュオブジェクトで置換する時、変数名だけは unique なものに置き換える必要がある

efficiency で満点取れたら超かっこいいので、頑張るぞーーーーー

少し考えに詰まったので考える。メモ化した時に色々破綻することはない…？
自分が考えたサンプルが、メモ化するタイミングで外側にキャプチャされてる変数がない例だったのでよかったけど、その場合に変数名とか勝手に変えると壊れそう。
と思ったけど、束縛変数は unique にする必要はあるけど、自由変数の名前は変えないということで対処できたりしないだろうか。

あと、（キャッシュの内部から見た時の）自由変数を、substitute のタイミングで置き換えてよいかについても考える必要があるけど、それは置き換えてよさそう。
キャッシュに取った時点で、完全に同等のオブジェクトになることが保証されているはずなので。
だから、β簡約の処理で lazy にパターンマッチしたら、キャッシュオブジェクトの中に潜って参照することは必要になる。

あと、lazy のように参照を持つオブジェクトを考えた時に無限ループに入る可能性もあるので、visited 葉管理した方がいいかもしれない。

## 26:06

Lazy のバグとりを一生しているけど、取れねーーーーー
lambda 9: lazy(9) lazy(9)
みたいなのが表れて明らかにバグっている。

# 4日目

## 7:37

無理でした！
悔しいーーーーーーーー
ということで、順位を最善に追っていきます。

とりあえず、どうやったら圧縮できるかを少し考えてみたい。
自明な圧縮としては、

- lambda s: concat s s

があると思うんだけど、これを機能させるには固定パターンの探索を見つけてやるとよさそう。
とりあえず順位を最善に追っていこうと思ったら全部提出したいけど、全部提出するだけなら手で解けば良さそう。

## 8:56

とりあえず手で解いて、最低1問ずつ submit した。やったね！

## 9:43

d3 の 2, 3 問目が解けそうだから頑張ってたけど、 test コマンドがパースエラーで死ぬので人権がない…

ふとこのテストコマンドの返り値を見て考えていた。

```markdown
B$ B$ L" B$ L# B$ v" B$ v# v# L# B$ v" B$ v# v# L" L# ? B= v# I! Su B. B$ v" B/ v# I@ BT I" BD B% v# I@ Su4qVj}89w~liM5"-)%$!.372nWP/,0[ I2`'!"<)=onX`lOs)W&]7{'uHU$.R"UG8q9v?FVa!`ER/)TS!
```

そんなに規則性のあるテキストには思えないんだけど、何でこんなに圧縮できるんだろう…？を考えていた。
もしかして、 str2int と int2str を駆使していけるのかな？というのを考えていた。つまり、

- 送りたいテキストを V: int とする
- 以下の2つの方法のうち、短い方を採用することで、整数 V を省コマンドで作る関数 f(x: int) -> int を考える
    1. 即値命令(`S...`)
    2. 以下のような再帰的な計算
        1. 表現したい文字列 S を数値化して v に
        2. q = floor(sqrt(v))
        3. r = v - q * q
        4. f(r) と f(v) を計算
        5. s = int2str(f(r)) + (λ.x x*x) f(v)
        6. int2str(s)

みたいな感じで出来るとよさそうな感じする。
ちょっと後で実験してみよう。

## 10:38

とりあえず、 3d2 と 3d3 は正の点数が取れた。
何となくわかってきたものはあるけど、おそらく適当なプログラミング言語の入出力から、簡単な処理系を作るんだろうなぁ…という気がしてる。
流石にコストがバカでかいので、一旦やめにしようかな。

次にカジュアルなのは、圧縮かなー。
とりあえず実験が最初

## 11:44

何にも減らなくて絶望してるので、理由を考えている。
v = q * q + r とした時に、v が n 桁だとすると、q も r も大体 n/2桁 位になるので、concat する時の損がでかい、ということなのだと思う。
マジかー最強の方法だと思ったのに！
（よく考えたら、圧縮の理屈がわかっていたら絶対そんなことないんだよな…と思うなどした）

そうすると、やっぱり元ある文字列をできるだけ類似のものを作って concat するのが強いのか？になりそうな気も。

## 12:05

ちょっとでもスコア上げるかということで、lambdamanの1～3が自明に最良スコア取れそうだったので手動でやった。
お昼休憩。

明らかに伸びしろがあるのは efficiency なんだよな。勉強も込みで出来たらやっぱり超かっこいいので、頑張りたい。
あとは spaceship のソルバをちゃんと書くのをやったら終わりなのかなー。

## 12:54

バグを一個直した。
あと、よく考えたら eval する場所を探すために再帰的に潜るために、何度も同じノードに入るのはダメそうなので、禁止してみる。
-> うおおおおおおおお efficiency problem 1 が通った！

https://www.kb.ecei.tohoku.ac.jp/~sumii/class/keisanki-software-kougaku-2005/lambda.pdf

これを見ると「最外最左簡約」なら停止するようにみえるので、何か実装が間違っているんだろうなぁ…

## 14:48

抽象構文木を眺めて考えてたんだけど、どうも実装は合ってるけど最適化が実装されていないから終わらないという感じに見える。

