3Dコースへようこそ！

昔、Bound Variableのカルトが地球上に存在していた時代、プログラミング言語はまだ非常に原始的でした。例えば、人々はプログラムを2次元で書いており、時間という3次元目を無視していました。明らかに、プログラムの時空間複雑性は3次元的であり、このコースではプログラムの時空間体積を最適化する方法を学びます。

以下は、時間旅行を志向したプログラミング言語である3D言語の完全なリファレンスです。時空間体積を可能な限り小さくするために、プログラムは時間軸を小さく保つためにタイムワープを使用できます。

# 構文

3Dプログラムは、セルの2Dグリッドを表すテキストファイルです。行は改行で区切られ、各行内のセルは空白で区切られた非空白トークンで表されます。

列を揃えるためにセル間に余分な空白を追加することは人間に優しいですが、必須ではありません。各行は個別に処理されます。行の長さは揃える必要はなく、短い行は左揃えで右が空と見なされます。

## 使用可能なトークン

* `.` は空のセルを表します
* `-99`から`99`（含む）の間の整数はその整数を表します
* 以下の文字
  `<`, `>`, `^`, `v`, `+`, `-`, `*`, `/`, `%`, `@`, `=`, `#`, `S`, `A`, `B`
  は演算子を表します。
  その意味については[演算子リファレンス](#operator-reference)を参照してください。

# セマンティクス

ボードは無限の2Dセルグリッドです。各セルは空であるか、値を含むかのどちらかです。値は任意の大きさの整数または演算子です。

プログラムには任意の大きさの整数リテラルを含めることはできません。整数リテラルは`-99`から`99`の範囲内でのみ使用できます。これはソースコード上の制約です。実行時には、プログラムは任意の大きさの整数で計算できます。

## 基本的な2D削減

時間はティックと呼ばれる離散単位で流れます。初期のボードはソースコードと同一であり、その時間座標は`t=1`です。各ティックごとに、ボード全体で一斉に1ラウンドの削減が行われます。

[演算子リファレンス](#operator-reference)はすべての演算子の削減ルールを定義しています。一般に、すべての演算子はその周囲に局所的な書き換えを行います。例えば、「右移動」演算子`>`は`x > .`を`. > x`に書き換えます。

演算子も値であるため、`+ > .`は`. > +`に削減されます。このようにして、演算子をシャッフルすることも可能です。

二項演算子、例えば`+`、`*`、または`-`は以下のように削減されます：
```
. y .     .  .   .
x - .  ~> .  -  x-y
. . .     . x-y  .
```

演算子`A`と`B`は、パース後に入力値（もしあれば）に置き換えられます。このメカニズムはプログラムに異なる入力を与えるために使用されます。

演算子`S`はプログラムを終了し、答えを提出するために上書きできる演算子です。複数の異なる値を提出することはエラーですが、同じ値を同時に複数回提出することは問題ありません。

いくつかの削減原則：

1. 演算子の前提条件が満たされない場合、削減は行われません。例えば、二項演算子が1つのオペランドしか持たない場合、もう一方のオペランドが到着するまでそのままになります。

2. 演算子の出力は出力セルを上書きします。

   `1 > +`は`. > 1`に削減されます。

3. 値を読むとそれが削除/消費されます。

4. 2つの演算子が同じ入力セルから同時に値を読み取ることができます。両方の演算子は、入力値のコピーを受け取ってからボードから削除されます。

   `. < 6 > .`は`6 < . > 6`に削減されます。

5. 同じセルへの競合する書き込み（例：`3 > . < 3`や`3 > . < 4`）は許可されず、シミュレーションはクラッシュします。

6. 各ティックでは、すべての読み取り（および削除）はすべての書き込みの前に行われます。

   `1 > 2 > .`は`. > 1 > 2`に削減されます。

### 演算子リファレンス

以下の図では、一般にシンボル`.`は空のセルまたは任意の値を含むセルを表します。読みやすさのためにドットを使用しています。

矢印は任意のタイプの値（整数または演算子）を移動します。
```
. < x   ~>   x < .         x > .   ~>   . > x


  .            x             x            .
  ^     ~>     ^             v     ~>     v
  x            .             .            x
```

二項算術演算子は整数引数に対してのみ削減を行います。出力は右と下に同時に書き込みます。
```
. y .        .  .  .       . y .        .  .  .
x + .   ~>   .  + x+y      x * .   ~>   .  * x*y
. . .        . x+y .       . . .        . x*y .


. y .        .  .  .
x - .   ~>   .  - x-y
. . .        . x-y .
```

演算子`/`および`%`は商と剰余の演算を表します：演算子`/`は結果をゼロに向かって切り捨てます；
`x%y`は`x`と同じ符号を持ちます。

```
. y .        .  .  .       . y .        .  .  .
x / .   ~>   .  / x/y      x % .   ~>   .  % x%y
. . .        . x/y .       . . .        . x%y .
```

等価比較はその2つのオペランドが等しい場合にのみ削減されます。これは整数と演算子の両方に対して機能します。

```
. x .        . . .         . y .        . y .
x = .   ~>   . = x         x = .   ~>   x = .  (x!=yの場合)
. . .        . x .         . . .        . . .
```

反対に、不等号演算子はオペランドが等しくない場合にのみ削減されます：
```
. x .        . x .         . y .        . . .
x # .   ~>   x # .         x # .   ~>   . # y  (x!=yの場合)
. . .        . . .         . . .        . x .
```

演算子`A`と`B`には削減ルールが定義されていません。これらはプログラムコードに現れることがありますが、パース後に即座に入力値（もしあれば）に置き換えられます。

演算子`S`（「提出」）にも削減ルールが定義されていません。プログラムは演算子`S`を結果値で上書きすることによって結果を提出します。

タイムワープ演算子については[独自のセクション](#time-warp)で説明します。

## スコアリング

あなたのスコアはプログラムの総時空間体積です：
* 使用された最大X座標

マイナス使用された最小X座標+1
* ×（使用された最大Y座標マイナス使用された最小Y座標+1）
* ×（使用された最大T座標マイナス使用された最小T座標+1）

この定義において、「使用された」とはシミュレーション全体およびすべてのタイムワープを通じての範囲を指します。

## 制限

`1_000_000`ティック後、プログラムは現在の時間座標に関係なく、値を提出せずに終了します。

## タイムワープ

プログラムの時間複雑性（到達した最大時間座標）を減らすために時間旅行を使用できるかもしれません。時間旅行は（四項）ワープ演算子でトリガーされます：

```
 .  v  .
dx  @ dy
 . dt  .
```

これによりボードの歴史が`dt`ティック戻り、`@`演算子の座標から`(-dx, -dy)`のセルに値`v`が書き込まれます（負の符号に注意）。これにより、ターゲットボードの時間座標は変わらず、内容が変更されます。その後、シミュレーションは修正点から再開されます。

`dt`の最小値は`1`で、これは1ティック戻ることを意味します。

```
2 > . .        . > 2 .        2 > . .
. 2 @ 0   ~>   . 2 @ 0   ~>   2 2 @ 0
. . 1 .        . . 1 .        . . 1 .
```

### 時間旅行の原則

1. 時間は離散的であり、初期ボードでは`t=1`で始まります。

2. 各ティックごとに、時間`t`は1増加し、ボードはすべての演算子の動作に従って変化します。

3. タイムワープ演算子は、t=1（初期ボード）までの任意の過去の時点に時間を戻します。

4. `dt=0`での時間ワープは許可されません。

4. 時間`t`にワープした後、`t`以前の歴史は保持されますが、`t`以降の未来は破棄され、その新しいバージョンが再計算されます。

5. 2つの異なるワープ演算子が同じ目的地のセルに異なる値を書き込もうとすると、シミュレーションはクラッシュします。

   同じセルに同じ値をワープすることは問題ありません。異なるセルに異なる値をワープすることも問題ありません。（これは、異なる演算子が同じセルに同じ値を書き込むことを許可しない基本的な2D削減とは異なります。）

6. 2つの異なるワープ演算子が同じティック内で異なる時間に移動しようとすると、シミュレーションはクラッシュします。

7. 提出演算子が上書きされると、シミュレーション全体が停止します。

   ボードには複数の提出演算子が含まれている場合がありますが、同時に複数の提出演算子が上書きされると、シミュレーションはクラッシュします。

8. ボード上のどの演算子も削減できない場合、シミュレーションは値を提出せずに終了します。

# 例

例として、次のプログラムは`B`回ループして毎回`A`を加算することで`A * B`を計算します（例のために；もちろん`*`演算子も存在します）：

```
. . . . 0 . . . .
. B > . = . . . .
. v 1 . . > . . .
. . - . . . + S .
. . . . . ^ . . .
. . v . . 0 > . .
. . . . . . A + .
. 1 @ 6 . . < . .
. . 3 . 0 @ 3 . .
. . . . . 3 . . .
```

これを`A = 3`および`B = 4`で実行すると、このプログラムの時空間体積は`320`です（`vx * vy * vt = 8 * 10 * 4 = 320`）。実行トレースは[3d-example]で確認できます。

# 問題

利用可能な問題は次のとおりです：

* [3d1] ベストスコア: 2982
* [3d2] ベストスコア: 1920
* [3d3] ベストスコア: 1314
* [3d4] ベストスコア: 2080
* [3d5] ベストスコア: 3456
* [3d6] ベストスコア: 3840
* [3d7] ベストスコア: 8640
* [3d8] ベストスコア: 43680
* [3d9] ベストスコア: 17545
* [3d10] ベストスコア: 40261
* [3d11] ベストスコア: 182091
* [3d12] ベストスコア: 64260

ソリューションを提出するには、ICFP式が評価されて`solve 3dX`となり、次にあなたの3Dプログラムを送信します。例：

```
solve 3dX
. . . . .
. . . . .
. . . . .
```

スコアは秘密のテストケースに対する提出の時空間複雑性の合計であり、スコアが低いほど良いです。

# テスト

あなたの3Dプログラムをテストするには、次のように送信します：

```
test 3d A B
. . . . .
. . . . .
. . . . .
```

ここで`A`と`B`は、それぞれに対応する入力として与えられる整数値でなければなりません。`solve`コマンドとは異なり、`test`コマンドには`4`ティックの制限があります。